# 内存布局

TODO：

* 内部布局
* 【已解决】Unicorn模拟ARM代码：优化内存分配布局内存映射
* 【已解决】Unicorn模拟arm64函数：___lldb_unnamed_symbol2575$$akd优化内存代码布局和输出日志
* 可能涉及到
    * 【已解决】iPhone11中ARM汇编Stack栈指针SP的增长方向

---

对于Unicorn模拟指令代码执行来说，其中最关键的一步，其实就是：内存布局

此处内存布局，主要指的是：

在想让Unicorn能正常的执行指令之前，需要把相关的内容，放到对应的地址空间上，确保代码能顺利的执行。

内部布局，本身是个很大的概念。

此处，由浅入深，慢慢解释：

## CPU的核心核心逻辑

先介绍一下，为何要搞懂，内存布局。

首先，Unicorn要模拟的是CPU的运行。

而CPU的运行，本质上就是：从内存中读取指令，并运行指令（包括输出结果，到对应内存地址或寄存器）

## 内存中存放哪些东西

先直接贴个别人画的图，我加了点东西，好先有个大体的概念：

* 程序的典型的内存布局
    * ![typical_memory_layout](../../assets/img/typical_memory_layout.png)

### 代码

所以如果要让CPU能运行你的指令，你要先去把你的代码，放到内存中，供CPU读取。

所以，第一个优先要放到内存中的，就是：代码。

注：代码==指令==二进制==opcode

而你把代码放到具体哪个位置，就是内存布局中，代码的地址空间范围。

### 其他

而能让CPU顺利模拟运行你的代码之外，对于实际情况中，比如稍微复杂一点的代码，往往还有会涉及到其他一些内容：

* 函数的参数
* Stack栈
* heap堆
* 事先要写入特定内存的值

下面分别介绍一下：

#### 函数的参数

很多要模拟的函数，往往是有一些参数的，所以在模拟之前，要先把参数写入对应寄存器或内存，供模拟执行用。

比如，你模拟`add(int a, int b)`的二进制代码执行的话，就要把`a`和`b`的值先写好，比如放到ARM的寄存器`x0`和`x1`中，供模拟调用。

#### Stack栈

如果函数A内部调用了其他函数，比如B函数，C函数等，则往往又涉及到函数上下文的切换，底层具体实现就是涉及到Stack栈，在调用之前和之后，代码中会操作Stack，保存PC、LR、多个相关寄存器等等，所以，往往在模拟函数运行之前，也要先去设置好Stack。

#### heap堆

如果要模拟的函数，内部涉及到申请内存malloc等，则往往也要设置对应的headp堆，用于模拟内存管理提供动态申请和释放内存用。

#### 事先要写入特定内存的值

其他一些特殊情况中，要给特定内存地址写入特定地址，供后续代码模拟时调用。

一般普通的函数模拟，往往无需此过程。

## 内存地址空间范围

此处的Unicorn所模拟的内存，指的是虚拟内存。

虚拟内存的范围，空间大小，可以简单的理解为：

* 32位：2^32=`4GB`
* 64位：
    * 理论上：2^64=`16777216TB`
    * 实际上：一般也支持 >= `256TB` 的实际物理内存大小

-》所以，Unicorn模拟时，可以认为：

可用的内存空间大小：32位是`4GB`，64位是无限可用的，比如远不止`256TB`

## 内存布局举例

下面，通过具体例子，来解释，内存布局的

### 官网示例代码中的内存布局

已我们前面[运行测试代码](https://book.crifan.org/books/cpu_emulator_unicorn/website/init/run_test_code.html)中用到的官网示例代码[unicorn/sample_arm.py](https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/sample_arm.py)来说，其中就是：

* 要模拟执行的代码code
    * 具体是什么：`ARM_CODE   = b"\x37\x00\xa0\xe3\x03\x10\x42\xe0" # mov r0, #0x37; sub r1, r2, r3`
    * 具体放到内存什么地方=范围：`ADDRESS    = 0x10000`

意思是：

把代码`\x37\x00\xa0\xe3\x03\x10\x42\xe0`放到内存地址为`0x10000`开始的地方

就没了。是的。即没有我们提到的，函数参数，也没有Stack、Heap，特定地址写入特定值等内容

因为，此处要模拟的，只是一个代码片段，不是一个完整的函数。

此处只是官网示例的代码，用于演示运行，确保Unicorn模拟环境正常而已。所以没有用完整的函数，只是一小段代码而已。

此时的内存布局，可以理解为：

```bash
Mapped memory: Code     [0x0000000000010000 - 4GB]
```

或：

```bash
Mapped memory: Code     [0x0000000000010000 - 0x0000000000010008]
```

其中：0x0000000000010008 - 0x0000000000010000 = 8 = 上述代码的大小=字节个数

### 实际例子中的内存布局


之前自己的某个代码，经过优化后，内存布局如下：

```bash
Mapped memory: Code     [0x0000000000010000-0x0000000000410000]
Mapped memory: Libc     [0x0000000000500000-0x0000000000580000]
Mapped memory: Heap     [0x0000000000600000-0x0000000000700000]
Mapped memory: Stack    [0x0000000000700000-0x0000000000800000]
Mapped memory: Args     [0x0000000000800000-0x0000000000810000]
```

TODO：把相关，更新版本的内存布局的代码和输出结果，都贴过来，再解释，为何这么布局
